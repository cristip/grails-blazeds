<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>3 General Usage</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h4>Runtime configuration</h4><p class="paragraph"/>The plugin manages the configuration of BlazeDS. This includes configuring <code>flex.messaging.HttpFlexSession</code> as a listener in web.xml along with the <code>flex.rds.server.servlet.FrontEndServlet</code> servlet for use by Flash Builder. It also configures <code>/messagebroker/*</code> URLs to be intercepted and handled as BlazeDS requests.<p class="paragraph"/><h4>Data serialization</h4><p class="paragraph"/>There are a few options for configuring how class instances are serialized to clients. All of the standard BlazeDS rules apply, but having Hibernate in the mix complicates things because of lazy-loaded collections and many-to-one references.<p class="paragraph"/>By default an Open Session in View filter is registered unless this is disabled by setting <code>grails.plugin.blazeds.disableOpenSessionInView</code> to <code>true</code> in <code>Config.groovy</code>. This acts like the analagous interceptor that Grails registers for controller requests, starting and binding a thread-local Hibernate Session at the beginning of a BlazeDS request and flushing and closing it after the response is rendered. This allows you to not have to worry about lazy loading exceptions when using domain classes that refer to other lazy-loaded classes.<p class="paragraph"/>There's a significant performance concern here though since you can potentially render a very large object graph to the client when only a small amount of data is needed. One option is to use Data Transfer Objects (DTOs) that you create using data from persistent domain classes. This allow you to control exactly what data gets sent to your clients.<p class="paragraph"/>Another option is to use the data converters that the plugin registers for you by default. These include <a href="http://static.springsource.org/spring-flex/docs/1.5.x/javadoc-api/org/springframework/flex/core/io/HibernateProxyConverter.html" target="blank">HibernateProxyConverter</a> which sends a <code>null</code> value for any uninitialized many-to-one reference, and <a href="http://static.springsource.org/spring-flex/docs/1.5.x/javadoc-api/org/springframework/flex/core/io/PersistentCollectionConverterFactory.html" target="blank">PersistentCollectionConverterFactory</a> which does the same for uninitialized collections. You can explicitly initialize any required many-to-one references or collections using the <a href="http://docs.jboss.org/hibernate/stable/core/api/org/hibernate/Hibernate.html#initialize%28java.lang.Object%29" target="blank">org.hibernate.Hibernate.initialize()</a> method.<p class="paragraph"/>You can remove any of the configured converters (or add your own) by changing the value of <code>grails.plugin.blazeds.converterNames</code> in <code>Config.groovy</code>, which is &#91;'org.springframework.flex.core.io.HibernateProxyConverter, 'org.springframework'flex.core.io.PersistentCollectionConverterFactory', 'org.springframework.flex.core.io.JpaNumericAutogeneratedIdConverter'&#93; by default.<p class="paragraph"/><h4>Grails services as remote destinations</h4><p class="paragraph"/>It's simple to access a Grails service as a remote service from Flex - just annotate the service with the <code>org.springframework.flex.remoting.RemotingDestination</code> annotation. BlazeDS handles invoking method calls and marshalling parameters and return values for you.<p class="paragraph"/>One thing that's important to note is that although there is a <code>services-config.xml</code> configuration file (created when the BlazeDS plugin is installed) you probably won't need to make many changes there. In typical BlazeDS applications you would register remote services using XML, but Grails services are well suited as candidates for remote services.<p class="paragraph"/>The plugin also handles service reloading for you and re-registers recompiled annotated services as remoting destinations.<p class="paragraph"/><h4>Manual configuration</h4><p class="paragraph"/>You're not limited to using Grails services as the server-side implementation of remote services. You can use any class like you would in a non-Grails application, and the best place to configure this is in <code>grails-app/conf/spring/resources.groovy</code> using the BeanBuilder syntax equivalent of the Spring Flex XML configuration.<p class="paragraph"/>For example, this resources.groovy file contains four messaging destinations and two remoting destinations. Remoting destinations are configured like any other Spring bean, with the addition of a <code>flex.'remoting-destination'()</code> child element, optionally with configuration options. See the <a href="http://www.springsource.org/spring-flex" target="blank">Spring Flex</a> documentation for more information on what's available.<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> flex.management.jmx.MBeanServerGateway<p class="paragraph"/>beans = &#123;<p class="paragraph"/>   xmlns flex: 'http://www.springframework.org/schema/flex'<p class="paragraph"/>   flex.'message&#45;destination'(id: 'chat')
   flex.'message&#45;destination'(id: 'secured&#45;chat', 'send&#45;security&#45;constraint': 'trusted')
   flex.'message&#45;destination'(id: 'simple&#45;feed')
   flex.'message&#45;destination'(id: 'market&#45;feed', 'allow&#45;subtopics': <span class="java&#45;keyword">true</span>, 'subtopic&#45;separator': '.')<p class="paragraph"/>   securityHelper(Security3Helper) &#123;
      flex.'remoting&#45;destination'()
   &#125;<p class="paragraph"/>   RuntimeManagement(MBeanServerGateway) &#123;
      flex.'remoting&#45;destination'(channels: 'my&#45;amf, my&#45;secure&#45;amf')
   &#125;
&#125;</pre></div><p class="paragraph"/>
    
<script type="text/javascript">
	var _gaq = _gaq || [];
	_gaq.push(['_setAccount', 'UA-16219500-1']);
	_gaq.push(['_trackPageview']);

	(function() {
		var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
	})();
</script>
</body>
</html>
